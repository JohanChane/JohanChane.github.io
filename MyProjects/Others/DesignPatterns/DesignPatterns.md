Design Patterns
===

说明
---

GoF 23 种设计模式

[Online Server of PlantUML](http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000)

References
---

-   《设计模式：可复用面向对象软件的基础》
-   《Head First 设计模式》
-   <https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)>

Creational patterns（创建型模式）
---

### Abstract factory（抽象工厂）

意图

> 为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。

![](http://www.plantuml.com/plantuml/png/jP91ou9048Rlyols-7q4WjUGHIVet5_Orga4KzWT3r7-zzRKRKaBExGWWi_3l2_ZffQLuUPS0d1z93wH4LSGxXGLapaeJIBRMpPAyyxKUQCv6uGM7YzTAcl5o68Fs-KJySD4_6xYrZsrkNHyE2kX3IcciU7VlrZxkkyi32sSbXjYuf_akAG-PLCMLB7BS5-U2uwYcvpyav7ZF4VmZJqErWNGHpauOQvVaZIMf9oHVFuY2mChB2I3wzCP_Ogad7NmnO6Kghoxm7S0)

### Builder（生成器）

意图

> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

![](http://www.plantuml.com/plantuml/png/bL91RiCW4BppYfLFZYhx0KvYfMaV4FK73bvNI1GgMDf3cxyN79PQg9VwOfZTcPrPSV8qEGflMWYf9-_XukmS9C6Nk0cX3A5R9ebm3ahFw28CyNk0QxfV8lMntTNGEK8trdkoHZea_9y0Gwz8B-Y3fdO70tlx5NzM3YLPLktWcgSCR3ZhI6iykI3lEXzMpHk7Mg79WMktVVyz5Ya6cowFQQ3hR37n1taiwnpWS8Z5YN0SHPwOwanU6u9FLM4i8MXS2EnI6eQXsOHeKYvEsrUxh0gyKJGp9EbgmDtCIgi3oEf-18EVTLUxsw_aacJEXzpEU5kfPHftzoKT2_BgtlF_MFlfDwzZlubtYiVqedy0)

### Factory method（工厂方法）

意图

> 定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的实例化下放到子类。

![](http://www.plantuml.com/plantuml/png/SoWkIImgAStDuShCAqajIajCJbK8ACfFAKqkKQZcgkNYIiv9B2vMSCxFAqejIKMHGMXmBafDBCal0Weh086sGZA8dwgXgM05Cml39EAqe5chfrTZ1vT6DGWY1-LWojcX-y1AmSO6OgUT7HTNNdv9ga9EQbg9GduQp10hAoMOevJ0ZjJNLtYwhEdPl3dFvdG-NJBhoOvLJrktFzax-SckvKydDuALG3MKL1QaQZvkQE9ApKjH09dDnUK0P8926G00)

### Prototype（原型）

意图

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

![](http://www.plantuml.com/plantuml/png/dPBFIiD04CRl-nH3JYsI53q6b88lu2k4EC70EXCsKwIeK0h-WO8Fu471OmN5KuklOrFYMvY49HjA3j8zxJBVzyrlXXtd4XcPN6gbKX8qIHGZd1aMbcc6SAsWEWSGQoOS325qDNMhLAoZF8TJfjYWO5iwtDDtz4-VJf74Qdt8MjgEskPmXYQIb6amhFqzf45mSzAnzJ3jADnoFBzjxO7limLJYbWGD2O2dFHi9mmzEv_NO5RLYI6G2uIOisbjob4d2kaSwgZTmAPB5UA6iq6Z4HGVRzl7LVcvsdxDD-lPPhqidbwBbqLnj_XzlYyVbkNt-yzitiZT98HNxd7iDXfOpWxAkBhMt-KF)

### Singleton（单件）

意图

> 确保一个类只有一个实例，并提供对该实例的全局访问。

![](http://www.plantuml.com/plantuml/png/VLB1IiD04BtlLmpj9KLjxos5YdZefPSAdjTaqYnkPdKpswAIitWIFFW7Ve17GV1hBFWNhccico2PIuR9Us_cxSoiO6dPvLg8MCkYWAMYbKOs17S2V1o18tNjS4uUIJ72E8Ju6gkuh97x7z6WgXp02lcN60t-fvP2a644ZIc3IVyWut6lGUzLcgCHzFjzsDu_RLyVjizld--FLTqYEqkjOKL8-NhvQ59K6hMyJQT0Jkk1jrv7SKDnPWsfMqoY_MZ3wgq2MDtcF4E2t5W4pYG1RunFBCga0Ei85F5F0I5Ljk2g5SGPnfTGoDnpL8w7RKdFa6kZ4b3ra4dGm53D0iL0YBwFnr_WJjL3vKeg6eQQtQvRCLyipuuN9wVW4RW9zpjfO4lHpCfW9NkHYK1AW0nZnyQRetMl_CggjMI4tIL1gaZguCBQBjiMsiVHARussdyrTkexhGEFCv-wN8jl)

[有两种方式实现](https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)

1.  懒汉方式。指全局的单例实例在第一次被使用时构建。
2.  饿汉方式。指全局的单例实例在类装载时构建。

Structural patterns（结构型模式）
---

### Adapter（适配器）

意图

> 将某个类的接口转换成客户端期望的另一个接口表示。适配器模式可以消除由于接口不匹配所造成的类兼容性问题。

#### Object adapter（对象适配器）

用组合的方法实现。

![](http://www.plantuml.com/plantuml/png/T8xDQiCm48Jl-nI3JYt5XbvTA2szzr3w0a8U5OChETBwbEJTGumaGaoEk_CptqTMctJzdqMce4pUEkBNfZygZW80BqWyhCpwz2nd4JVRdF4LWqjKDcTJFaUxA5C9Tx3RJGn5uUFIOcYxUQ6R_EH-Rgrtotr_UY-yKgVtFwBh8anXCHLI94GbPdf5zFKx3AR1cGsbvFeTq9imZBYMb2gRyVswPUhmPKzszC72y_di7K_sx7c_f-Tf_wfdCzO_czFvj7t1anshdlKjVTg_-CcEtgSJUXutD86rF-rV_tpA2hWfJrjRd-wT33TeLilJjHEURzmDL0tpzDCD6u5cljYx1cJQp1L0MvxitG_N_wXXpjF-6Syw9Zngc8ja2j28f_EwGNOY_E40P8BI0m00)

#### Class adapter（类适配器）

用多继承的方法实现。

![](http://www.plantuml.com/plantuml/png/T8v12i9034NtEKNeIf4ARYk8ujw5U84u_PM1iQqpgHlrxbRi35Kno_oN_BSEAbwxioCoJaBWW_WJb6_4_SpOuz8Xw6HAZqXiczfuA1APaaqfhSB_FKu84X9Q65jPin-ZNmrvVbyDNXGhHZikkFNsAegFD5NrSNTqrX3LZO8TAkMcYh95aINDZBWVUT_DVzIMXBharvFXbGJUBPvDqK4AmZ0K1D2hURGW5XLh4z15rIg22AKejRk02Twb_adSUGL_X7wwooBp9aDIHhh85iEhui6ISr-NGpUXR4ErnFnCjWd55Vf2TWsJlzNq7uTkuxOM1La6ln5eFyFTnEx9juU1U7HiVlmjQRkQMyY_9D-h2heC2zEhuqXX0gSLAwCT4pwct_y1)

### Bridge（桥接）

意图

> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。

![](http://www.plantuml.com/plantuml/png/ZP4nhiCW38Ptdy9YUazFv00Pdb9rwjeRK68a908Hk5EQknUQLYLDXdh2ykyF_fykiOfy7Ho0kYIEIZDgfrB2mxErmUC4c4kY7KP70taE4LiylRl7_0_3I56LZPzVd5wy6MQ0XNacOptrM_HgjUYjPuf6QQflsOhpSD4l_6FmEXBJTpixhv7ozbyxXprYqsHHRRuU2bc5938mh7ZW0nCwCep1xEJHjg9AGW3cge3DXmloFHOYG9UFvHll)

### Composite（组合）

意图

> 把多个对象组成树状结构来表示局部与整体，这样用户可以一样的对待单个对象和对象的组合。（一个结点或多个结点都可看作是一棵树）

![](http://www.plantuml.com/plantuml/png/jPBFIiD048Vl-nH3JYqsWjSWfT1hyHtMP683oKxPdNfH8OWK3mKzYhv1BrvxqASnzS_9Lt2pZTaKUksS9ZEJVByFCZ8iDS-BN0XvRbZBc27EfJ4mfc962XN3bG1RHn3JN76l3n5aYfkPJ99Ul-ar5dI9xUC5ydYQvNvFCzIICr9sSYF45ZD1cHwCu4LCnjXWGeZhbpGgovbaXazRrU5XSZZ7CBmUGaiIFjMUXUiW2F-31lQ8l8WGYXWXnvI1KZ-Feg133boOb3IWZATRQUlJsWjeoWsEkvbH9Q2e1Ka3PoVkl3OPU21yFhrMwx9Qhxp0xzkoUb-uIzWyhFPS3E2xNEv-n2_Xw_dkvsMnURp_A6yxGKQshN_JFm00)

### Decorator（装饰）

意图

> 动态地给一个对象添加一些额外的职责。就增加功能来说， 装饰模式相比生成子类更为灵活。

![](http://www.plantuml.com/plantuml/png/ZL9RIiH04FplKpIRduXi5lsCAElZ8kDi1nQoqykaHK7t5Xx2IuYN4Ro6apYRZhG1vwipLTLLbMJTYOloi6i1ja4eDiuJtl9kpu62u3DWEgV8UufEjXpA4pW0-DPrNQ857qd8qWsIP7ykSlUTHES5VpRUaUS4S_oViQKRfFHZk5fxpQInXQhgvKfbO8sNoqGO7q41eynJKl140865iAL6a1iRlwuNauoB8VRa8lVkpzYpck0N0tm02XliZRAT6rwXq9CC-6g5HL7Wv_l7r-jRVwEvTIrUOg17HOxBjV7cE9rbhcbphLzZNdq-fxufrI7BLVIxjVPTfx7_kxy1)

### Facade（外观）

意图

> 为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

![](http://www.plantuml.com/plantuml/png/ZP9DQiCm48NtSueXAuU2WwMTcvf0e1Ve2OGyTaqLgSGoNOJSlL8q9OeHRRMGxF7tvkTPXzchirzE1a0RDS_ughJg2I-0OJrXxzxSYVpxPCTg2rS0xyRmIcScFfN-K2Fzd4qCyqhvZd7FmrT8UqakodBnJxaiosL17XBmf7NTtRjlSR-Vh3PBJrrN8CIVX5mHS3GJMT_S6CRRbQq94RyXQzzvFCvzoKt9Fx5pQM3hFA6XmQCRk4xRRXxgR6uq_pETZXUqzCMnQljy9qGYH4w81q8cGkQ434JMQ5E71lmo35LAnlBTBhXH0zaUOzi0X_0Oh-at)

### Flyweight（享元）

意图

> 运用共享技术有效地支持大量细粒度的对象。

例子

> 典型的享元模式的例子为文书处理器中以图形结构来表示字符。一个做法是，每个字形有其字型外观, 字模 metrics, 和其它格式资讯，但这会使每个字符就耗用上千字节。取而代之的是，每个字符参照到一个共享字形物件，此物件会被其它有共同特质的字符所分享；只有每个字符（文件中或页面中）的位置才需要另外储存。
>
> *位置是内部状态，存储在享元中，而字型外观，字模等是外部状态，存储在享元外部，所有享元共享。*

![](http://www.plantuml.com/plantuml/png/d95HQiCm44J_TOh1Nmd5Fe0JJA6G2vGUGCZZM5ILWhGX2MdkNfocZh5IADqlutspEpjwJgAZx3-SKjOBOwSDiN6d0-ss5vmL03mXx1YrsE0NF4gqFbdpAbguL1UbZDCfuILu4ocSYqjOFvNyVUARJxsERCV9_x4rYZRQI8YdKRkbZBt5EqzBr7TuSfQpz8Bpy2StKbMVpKJrY-CSl3UAillvJWNACcIErSr2LJNvDJNMwtrYqqofRFrZB7URuye78HmxGUYozNLTP34MrtnjXqMUi4tWqIP9o-4PRXKf--Y_6zPlCUQnkY8Nq2LEU1EfXV0ypD6XTDl22YH0Uc8NWXkCtpDUpVTA_t3MHT6t6Ax_6beOG08GhERfsXbFcrOytRdj-Rg5poUqFUjiU3Qdy-dwdIysBdm-gqK1DKqMFsve0kjwFcM5GW9wIEfX19OUpiITeF1qmyQd_UkVx5_tRCfED6j0jY1SxW1aWZ8t0000)

### Proxy（代理）

意图

> 为其他对象提供一个代理以控制对这个对象的访问。

![](http://www.plantuml.com/plantuml/png/bPB1IiGm48RlUOgXfoxIxBsxbWLVGFG9uZgxMub9IQQegEzkEfdAU14sXnAc___DH-aXaqiqltfZA9wHBfZWqq0vH-zoXiVvwGMFnBDwRY1Ec1oDCRGRdduRLNX0vwyktQVu_g7Y7MH1zAl1lwW2gw0xFs8eYvU9Dh7sQ_WbyRQ_epNNTBAuWQwBrSi8r5h9izP-FsSS1cD290IF9u9ugeM-RvHYmuxRRUbRlie6gp8wWk4P5gQGqtY-CBfQS7Ar41BSGi0t_UNRpOw3h0CJFsk89wqK9SNljSvEIHpATVazVW00)

Behavioural patterns（行为模式）
---

### Chain of responsibility（责任链）

意图

> 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

![](http://www.plantuml.com/plantuml/png/RO_1ReCm44Jl-nKZJgqg_04eGf5wwRb_u3fBW-JOgdTzelnxWmDkHB8dc9qPlpsAsgJvuib-YIRh5CvR4NpOSFASC16kqqAoSomI4xfjLpPlE9U_J_x9BFhoYcbhccackhMzn-0IAzVMvzcxW1yvAAP5sOUD-UqhmoOsRILiqBQn6jOcOse67Gw7BDptH24gm_EWYCEUikkQ7LzJiCS1peQLVJrbcPsvw3FOoxsfKfgdTk9mmWAregNn-rpORcVG_pkF1JLwl7xbY_y3)

### Command（命令）

意图

> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
>
> *请求最终会调用接收者具体实现的功能，而调用者只需调用设置好的请求即可。*

![](http://www.plantuml.com/plantuml/png/VLHFJzH05B_FftZfQGcs18zL2OadBnxu1hKEsjXjatP04oLPGU9Y28H8rAZHQCG_bu8NLjqjNyQTTcxx5PnsvasXLVUoapVllT-VtwJBAVCIjjOF2V5kfIpnV0P-wAKfN8_xVI-w3Gy9o9yD2VLfi4uJS6557-kRUV1LP-yl7NEwXJwW_XgZlJcoGGZkZ_o4CjhWcAiRqNfyZoO8ZG3W8YczDQLC5tgTbXOozZK4a2F2p8FK7iJH1OvXG2EcgBNvslQZ9SEdASPWsPgCXKA8WLBtQ9HbvaaKCmeXNMKGhsBLTItZcrLpn447gLuXLA9MmwqLY5nDePs1_hy64RsFLRcZRbfO09vzB8OZaPsLUSQFylBr4tH-DXcAur7nVNCssQcwSPNJJQ1UPp2TjltQR4JSF-1FVwdLM4TC74M26ssfIN3dRgrLfOGg57-rKqeezewAmrCnsAxlCGXq4it0Ee9fliX5TRMVh7dmtHYy56uk8gFfZx7u_BXyarLqNXsBx9k9f7WxACT3SR9L7duzRt_b_KexR9a2V_PUR5N9yEtHD7_EitVbtWc6ikZ0nGmFykduqtaFBlr3s5LTNcearHilEm2Ad1pc-o_usSlk8r4miyak_tbQx7mH7tQx4VuURFv7gk7NVU1oiF5sMPwgJzKV)

### Interpreter（解释器）

意图

> 给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。

例子：`C++ 布尔表达式`

> TerminalExp: true, false, <value>  
> NonTerminalExp: and, or, not

![](http://www.plantuml.com/plantuml/png/SoWkIImgAStDuU9ApaaiBbPmpiyhIQqeKQZcgkNYoWIoYz8IarCLN2iAYbABYpFpyu0o2a2WhG2M18gMQ2H3zLZ1T6jorSBC2qajoitCIymXsm2__3oSPkWgfCA5Ye6w4Gf8ii8v9pCr3-fbB7RfwTNO8HiDSX5XLKXIIhe8Poe15UPZznGNn1r01NOAM4LXJkVYoiilILN8IKqhKSXFWuc2lVoqf_NfXDKlbYz-sTxrTEQA9pkxdowPzdnMovCT3KzspNxQkkBfneOd-nS-Qrp_kA69ApKlHG5a59g1O1iXvYcysD3yVCeAY87F9lS-sJi7LQC3a0bAFW00)

### Iterator（迭代器）

意图

> 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。

![](http://www.plantuml.com/plantuml/png/XLJFQlCm3B_xAKHF2Hzrxsc_qBBJOEmTt4nD3Qa3jiesjhpxB6p78Jwa9zlw_P5-2ZqxKfQUZq68Rb3EmIlX0tx498GsXFQcEkGtgsYq_Xtyxn_SbNl7BwhgU3VXCYMHbz5q5WbNn3reh-wWWJVjwCHMRL0e69NgBVQAq8ClyLYltNtjEeu3AfFwICyipUsegoEhEeBGLrAQ1_6UAficQkmvaQToi2IqELZ1gEfjwuZeaLZ9SMqfdBiPD1eAsoeYb_AtpOf5u_kzBwURI0VFQiljDN0wXNRRLeZeoiYPneYdu_AYclbpLPZHemUy4Oot8fkcsPLnxGJu7zsrao7a_s3m4oxMgkySIbKV1PeFOFrjbtNsmSE3djQKdo9xrrlg2PrcsFgMox4WmUIy-CBLwlxEjd7rh35BploOK1dbaV5vBJeT5jRhP0BbSCXWAUMYgxC_yh_77m00)

### Mediator（中介者）

意图

> 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
>
> Colleagues 都聚合 Mediator，Mediator 也都聚合 Colleagues 即可。这样 Colleagues 之间不用相互聚合。

![](http://www.plantuml.com/plantuml/png/ZLJ1IiD04BtlLmmvjSXkQOuHfE1P1Fs2DPtKG9f0CZtLWZUlwj6JP_q3yNCKwb-u2PbTsjs4vZJBl3TltjibYuPqJPjr8OI-QwZMAK5QwAQ1oweeKAys25i1vfEmncMkgQeXWQk-x3fdi4Aw9KqucSAMn-pwdYdpgZpix8HWaJAjaT2ApM7hpJmQDCAEJsFd9M6TwHIj3-Rr7d6IMlU9Io8WVJH0GkexIW8sXz1n21sVl5mWJoaVBXpAHyG326TDATFda-028iaF8W8fgp6DkG7xmJ3jK2wmOOWT3x15MH52WHb1bNdj98d6GuowgFCCN5-vjpJjhxdzPZDGIjcZRq_P9yUOwvjXU6pXvnre9x1SGcjcm98JCgQO6mct6fS_ts-_pozWVBS9cEFxt-Fh_kbZ__NPGVWM5IT3ztbZjd3w2rEsluX_)

### Memento（备忘录）

意图

> 备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。

![](http://www.plantuml.com/plantuml/png/VP9DQiCm48NtSug75oMXs0TmKnFekdJH4uXq4a9j2QGnNPJUlV98Gg8_sOtyllbcBFiOn7XPbvdeD9iGyCmBMt7u903e4NDXhUznONdTZhizHcXLe18eNS8zVHNhYxzUhjQ8yt-AJvxZ8OzMUwvpxZd4LjujwMdDcn5FnhEOTwuJVj4Rd4jqVOuxzBshtTIiEWmJ2Z_YS4XhuWvhu6cYqfF0sgTiGiWwOSny5hXpWunZz-ETErqw2bTlOVa39GbwbG_4zWsRxPRpttlAUdNX4JaVwWTj_STORd_4Dm00)

### Observer（观察者）

意图

> 在对象间定义一个一对多的联系性，由此当一个对象改变了状态，所有其他相关的对象会被通知并且自动刷新。

![](http://www.plantuml.com/plantuml/png/XP9HQiGW48RVFSMGfombEK2WPQ47wCEUm2HZcsArwAHGjdltZcIKu0RM5yNvyytylpb7qe7MBwlKuWY3qHF2snWn_620gm9UJx1-pvgmFQcRKfFLCSAhTrD0mahQGLp7Jvm81hXi9xdt8hmGar8rxGTuFKOAcW5R7u70jS946CgOGj54Ulfeis8dE8bYnaSAvsanlqT6wq74vv6TTzoksqoDvI9nxwBh-xyNA6RgXbt7rPnb-QRfIX8DItnHoCu2cN0hrqsLOgi85Ws1DtVbOMZoepJ9HFLypzb-l_EAReO4hT0o41CbN24Q7q1R2nuML_0nvIlBzsc44kDjr-3Cn_JF_WC0)

### State（状态）

意图

> 让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能获取的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。

![](http://www.plantuml.com/plantuml/png/bLFDJi904BxlKqnweZ4jqMD93E8Zy09Tom2DjOtT0KoKHACdOzG3HYC7F7hquey4zMKevUOhIDTjqt8mE9UsCz_txJTVirL1FAJEdiUOwnE6JUuWr8aJmY63HQr1c_iD3qiwMD0Dt0RhC-PuN0ZO3dmdH489t_edlhOIdl205D00aV0KASJz3WhAMAhTGfBgib_FuKKwa2BfS8djBAoqfBsYdQL5JVDeKuaNLyfFc7o0PiW3DJ2C85s8CJyW10-R144pxLgMbYsbIKEIQQRnCFGRa10LFNHRxIL-th_IA9TXDhgUZeVHvIWQFaIJc_dpQtp-CZi-cGtUewkxxyd5zECh-hm5EplUXldJQJnuZ8TlqNWGtv-1NVHY__hhkUIqIrtkTL1NVoafXmk4TOj1hhByVUn1CS-IhbSAs9qG-MwbABUngbpjRpcPY6cQyhEVoxIwU4skmGy0)

### Strategy（策略）

意图

> 定义一个算法的系列，将其各个分装，并且使他们有交互性。策略模式使得算法在用户使用的时候能独立的改变。

例子

> 有许多算法可对一个正文流进行分行。将这些算法硬编进使用它们的类中是不可取的。不同的时候需要不同的算法。

![](http://www.plantuml.com/plantuml/png/ZP11oi8m58JtSuf7Ll-Ff0Ue80MFu0b2VMq3RPuaJr3Kkzjg8WKtPfKPvfi9QPAwgETf17nGZfrhcGuQdN9_fHjeFXjoOo_Hwp3z_UC1jADBYVOIsiZAFwULBvf3bbAcCYCddhMNy6Q-kglglgEYyB6j5JAsT9co0WHHfkZxGKcwOjUrMUsOrtHXgzMhj-1mfAK2QERhyZrF)

### Template method（模板方法）

意图

> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

![](http://www.plantuml.com/plantuml/png/SoWkIImgAStDuU9AJ2ekAKfCBb58paaiBbPmX7ATmRngBWKWq5OeISqjo4aiIVLDBSd8Jz7GX0eN56NcPfPabgNw5wGM9PPavkSvQcWgLCEChCMfp0bLMIqN5yHsv_oyvABKabIexVYimMSso41KetHrQ-nG_SR5bPTVaggGavfMef2VXYfdPQM4xcCbi7tw-We9w3892a-tRtgwRjxplWtlz_IyQEXvDgVpoQxPpwRjVBPvwejbZSysDZrTE-7vnjqGDOyRcc16wUdfWPZO_MTDM9KJcghKl1G5aAUuk1o0J53i0W00)

### Visitor（访问者）

意图

> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

例子

> 考虑一个编译器，它将源程序表示为一个抽象语法树。该编译器需在抽象语法树上实施某些操作以进行“静态语义”分析，例如检查是否所有的变量都已经被定义了。它也需要生成代码。因此它可能要定义许多操作以进行类型检查、代码优化、流程分析，检查变量是否在使用前被赋初值，等等。
>
> Visitor（作用于元素的操作）: 检查变量是否被定义了；类型检查；检查变量是否在使用前被赋值。  
> Element: 抽象语法树（objectStructure）的节点。

![](http://www.plantuml.com/plantuml/png/pLMnxz906DtlhxWmjJ4juSQ64DGuEvZeNCzhh1uzqbvPb8I844ZKcEY4n3WwEZWO0_upqg8J_u87_LhQguY__1Qwm7tlVU-z--uAtKYweOnx724_a2pqNChmVJ_ofGZnCuJLSmCFzklR8g0Xa-mEPpqMo9P1jG9siCun_o50T05I5o0c6Y94kHj51GJXMXUTZbnAkkEXGha8vbBA-j8Om5ax-QcNDwMdFDiBkEYpq9M-26uQf-N8rULkbUNkFdp2gBmdmvZAE6IWPc4gE5U0efUikQyS2uhGMXrT37YG28wdSlsg359d40YVQpnm-LF3h1O955NEsgnj-ta7mqf7YOPgsJ8KLZfAgYXeu8Prd5i3MvQeZGHcQDj5izfqknr7hDCfWrfVYOG28Hdcp9DOU3hFSHgb18Sv9PFnzkkdxUBbxm_JvErijthrQxnEFousttvabMGwKMX6-pbwWLZm2EyzD2Tzjihgv9NBdA5k__tjbO_zoFnFCt8zCtB6x31sPL6vPQ3RREBaopHzztgpNkvMCw3iLdErthx_lFd-flOYg6ccyr6wd6SpFSXuAhAHNnC6duxUQiBBfPwSP5Vt3Rzemz9Ukkhh_h_d3m00)
