## # Auto Make Application

# 自动构建 CPP 程序的通用 makefile

# 文件名不要有下划线
# 产生临时文件：<相对目录><文件名>.d, <相对目录><文件名>.o

# `##` 为 markdown 的标题

## ### Refers
# moby's makefile

## ### Variables

# 源文件目录
SRCDIR := .

# 源代码文件的后缀
SRC_SUFFIX := .cpp

# App name
BINARY := app

# App 放置处
DEST_BINARY := app_installed

# 使用的编译器
CXX = g++

# 编译参数
# CXXINCS = -I .
CXXINCS = 
CXXFLAGS += $(CXXINCS)

# 加载库
LDLIBS = 
LDFLAGS = -L.

# Generic Make
# SRCDIR and BINARY must be defined before making

.PHONY: all clean cleantarget install
all: cleantarget $(BINARY)

# Analyze project 
SRC_FILES := $(shell find $(SRCDIR) -name "*$(SRC_SUFFIX)")
INC_DIR   := $(addprefix -I,$(shell find $(SRCDIR) -type d | egrep -v '\.\.$$|\.svn'))
OBJ_FILES := $(subst /,_,$(subst $(SRCDIR)/,,$(SRC_FILES:%$(SRC_SUFFIX)=%.o)))
DEP_FILES := $(subst /,_,$(subst $(SRCDIR)/,,$(SRC_FILES:%$(SRC_SUFFIX)=%.d)))

CXXFLAGS += $(INC_DIR)

## #### debug
# echo $(SRC_FILES)
# echo $(INC_DIR)
# echo $(OBJ_FILES)
# echo $(DEP_FILES)

## ### Rules

# Include dependence。
# include <files> 会转到与 files 相关的目标，然后执行其命令。
# make clean 就不必产生依赖文件了
ifneq ($(MAKECMDGOALS),clean)
-include $(DEP_FILES)
endif

# Generate dependence, including rules to generate object files 
# 为每个 target 产生一个 dep file。-MM 不包含系统头文件。
%.d:
	@echo Generate $@ ... 
    
    # 为生成目标文件添加命令
	@$(CXX) -MM $(CXXFLAGS) $(SRCDIR)/$(subst _,/,$*)$(SRC_SUFFIX) > $@.$$$$; \
	sed 's,.*:,$*.o:,g' < $@.$$$$ >$@; \
	echo '	$(CXX) -c $$(CXXFLAGS) $(SRCDIR)/$(subst _,/,$*)$(SRC_SUFFIX) -o $*.o' >>$@; \
	# 添加 .d 文件作为目标，源文件作为依赖。因为源文件的修改，则要更新 .d 文件。
	echo '$@: $(SRCDIR)/$(subst _,/,$*)$(SRC_SUFFIX)' >> $@; \
	rm -f $@.$$$$;

# make app
$(BINARY): $(OBJ_FILES)
	$(CXX) $(CXXFLAGS) $^ $(LDFLAGS) $(LDLIBS) -o $@

# Clean project
cleantarget: 
	rm -rf $(BINARY)

clean:
	rm -rf $(BINARY) $(OBJ_FILES) $(DEP_FILES) *.d.* 2>/dev/null

install:
	cp -f $(BINARY) $(DEST_BINARY)
